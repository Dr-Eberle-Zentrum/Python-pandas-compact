---
title: "Visualisierung"
teaching: 15
exercises: 10
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# load tidyverse
suppressPackageStartupMessages(library(tidyverse))
```


:::::::::::::::::::::::::::::::::::::: questions

- Wie visualisiere ich Daten?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Datenvisualisierung mit Dataframes und `plotnine` in Python

::::::::::::::::::::::::::::::::::::::::::::::::

Die Visualisierung von Daten ist ein wichtiger Bestandteil der Datenanalyse, da sie es ermöglicht, Muster und Zusammenhänge in den Daten zu erkennen und zu kommunizieren. In Python gibt es mehrere Pakete für Datenvisualisierung. Ein beliebtes, das wir auch hier vorstellen werden, ist `plotnine`, das auf *ggplot* und der [*Grammar of Graphics*](https://r4ds.had.co.nz/data-visualisation.html) basiert. Hierbei müssen die Daten in tabellarischer Form vorliegen, d.h. jede Zeile entspricht einem Datensatz und jede Spalte einer Variable ("tidy data").

Die Visualisierung von Daten wird in verschiedene Schichten (z.B. Punkte, Linien, Balken) und Eigenschaften (z.B. x-Achse, y-Achse, Farbe, Form) unterteilt. Die Verküpfung von Tabellenspalten mit den Ebenen und Eigenschaften (d.h. Welche Information wird wie fürs Plotting verwendet) erfolgt über die Funktion `aes()`. Geometrische Schichten (z.B. Balken, Linien, Punkte) werden mit `geom_*()` Funktionen hinzugefügt.

Im Folgenden wird ein umfangreiches Beispiel für die Visualisierung von Daten mit `plotnine` gezeigt, bei dem die Anzahl der Stürme pro Jahr visualisiert wird.

```{python}
import pandas as pd

# Alle Funktionen des Pakets plotnine importieren
from plotnine import *

# Sturmdaten aus dem Internet laden
storms = pd.read_csv("https://raw.githubusercontent.com/tidyverse/dplyr/master/data-raw/storms.csv")

# Zunächst einen Dataframe mit der Anzahl der Stürme pro Jahr erstellen
storms_per_year = (storms
    # Duplikate entfernen um nur die Spalten "year" und "name" behalten
    .drop_duplicates(["year", "name"])
    # Gruppieren nach Jahr
    .groupby("year")
    # Anzahl der Stürme ermitteln
    .size()
    # Ergebnis-Index in eine Spalte umwandeln
    .reset_index(name="n"))

# Plot erstellen
plot = (ggplot(storms_per_year, aes(x="year", y="n"))
    # Diagrammtitel und Achsenbeschriftung
    + labs(title="Anzahl der Stürme pro Jahr", x="Jahr", y="Anzahl")
    # grundlegende Diagrammformatierung
    + theme_minimal()
    # Balkendiagramm mit Anzahl der Stürme pro Jahr
    + geom_bar(fill="skyblue", stat="identity")
    # gepunktete horizontale Linie bei 20
    + geom_hline(yintercept=20, linetype="dotted", color="red")
    # Highlighting der Jahre mit mehr als 20 Stürmen
    + geom_vline(
        data=lambda x: x[x["n"] > 20],
        mapping=aes(xintercept="year"),
        color="red"     # Schriftfarbe rot
    )
    # Jahreszahlen der Jahre mit mehr als 20 Stürmen in schräger Textausrichtung
    + geom_text(
        data=lambda x: x[x["n"] > 20],
        mapping=aes(label="year", x="year", y="n"),
        angle=70,       # Schräge Textausrichtung
        nudge_y=1,      # Text leicht nach oben versetzen
        nudge_x=-0.8,   # Text leicht nach links versetzen
        size=8,         # Schriftgröße 8
        color="red"     # Schriftfarbe rot
    )    
)

# Plot anzeigen
plot.show()
``` 

```{python, eval=FALSE}
# optional: (zuletzt gemaltes) Diagramm speichern
plot.save("storms_per_year.png", width=10, height=10, dpi=300)
```


Als Nachschlagewerk empfiehlt sich das offizielle Cheat Sheet des `ggplot2` Pakets, welches die wichtigsten Funktionen und Argumente übersichtlich darstellt: 

[![ggplot2 cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/pngs/thumbnails/data-visualization-cheatsheet-thumbs.png){width="100%" alt="CLICK TO ENLARGE: cheat sheet for ggplot2 ackage"}](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf)

::::::::::::: challenge

## Sturmposition visualisieren

Zeichnen sie ein Punktdiagram, welches für folgenden Datensatz 

- Länge (x-Achse) und Breite (y-Achse) der Messung zeigt und die Punkte anhand des Sturmstatus einfärbt,
- die Achsen mit "Länge" und "Breite" beschriftet, und
- den Diagrammtitel "Sturmposition" hat.


```{r ggplot2-exercises, eval=FALSE}
storms |> 
  group_by(name,year) |> 
  slice_tail(n=1) |> 
  # .. TODO: ggplot2 code hier einfügen ..
```


:::::: solution

```{r ggplot2-exercises-solution}
storms |> 
  group_by(name,year) |> 
  slice_tail(n=1) |> 
  ggplot(mapping = aes(x = long, y = lat, color = status)) +
  geom_point() +
  labs(
    title="Sturmposition",
    x="Länge",
    y="Breite",
    color="Status" # ansonsten klein geschrieben
  )
# alternatively
# geom_title("Sturmposition") + geom_xlab("Länge") + geom_ylab("Breite") + geom_color("Status")

```

:::::::::::::::

:::::::::::::::::::::::



::::::::::::::::::::::::::::::::::::: keypoints

- `ggplot2` benötigt einen `data.frame` als Eingabe, welcher "tidy" ist (d.h. eine Zeile pro Beobachtung und eine Spalte pro Variable).
- Das `mapping` Argument ermöglicht mittels der `aes()` Funktion die Verknüpfung von Variablen des Datensatzes (d.h. Spaltennamen) mit visuellen Eigenschaften (z.B. x-Achse, Farbe, Größe).
- `geom_*` Funktionen fügen dem Plot Schichten hinzu (z.B. Punkte, Linien, Balken).
- `labs()` ermöglicht die Anpassung von Diagrammtitel und Achsenbeschriftung.
- `theme_*` Funktionen ermöglichen die Anpassung genereller Diagrammformatierungen (z.B. Hintergrundfarben, Schriftarten).
- Es gibt viele weitere Funktionen und Argumente, um die Darstellung von Diagrammen zu verfeinern (z.B. `facet_wrap()`, `scale_*`, `coord_*`).
- Diagramme mit `ggsave()` in beliebigem Dateiformat (PNG, PDF, SVG, ..) speichern.
- Ausserdem gibt es viele Erweiterungen für `ggplot2` (z.B. `ggplotly`, `ggrepel`), die zusätzliche Funktionalitäten oder Visualisierungstypen/-diagramme bieten.
- Zusammenfassung im [`ggplot2` Cheat Sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf)

::::::::::::::::::::::::::::::::::::::::::::::::

-----------------------------------------------

Dieses Dokument wurde mit Unterstützung von GitHub Copilot erstellt, einem KI-gestützten Autocompletion-Tool, das auf der OpenAI GPT-3-Technologie basiert.

